//**************************************
// Generated by mcpp translator
// Version 1.2
//**************************************

#include"public_m.h"
#include<assert.h>
void
TAppKeyID::__write(MLang::OutputStream&__os)const
{
	__os.write_int(app_id);
	__os.write_long(key_id);
}
void
TAppKeyID::__read(MLang::InputStream&__is)
{
	app_id=__is.read_int();
	key_id=__is.read_long();
}
UDataValue::UDataValue()
:__u_init(false),__u_index(0)
{
	memset(&__u_val,0,sizeof(__u_val));
}
UDataValue::~UDataValue()
{
	__clear();
}
UDataValue::UDataValue(const UDataValue&__val)
:__u_init(false),__u_index(0)
{
	*this=__val;
}
short
UDataValue::_d()const
{
	return __u_index;
}
UDataValue&
UDataValue::operator=(const UDataValue&__val)
{
	if(this == &__val)
		return *this;
	__clear();
	if(!__val.__u_init)
		return *this;
	__u_init=true;
	__u_index=__val.__u_index;
	switch(__u_index)
	{
	case(C_DATATYPE_STRING):
	{
		__u_val.c_string=new char[strlen(__val.__u_val.c_string)+1];
		strcpy(__u_val.c_string,__val.__u_val.c_string);
		break;
	}
	case(C_DATATYPE_UCHAR):
	{
		__u_val.c_uchar=__val.__u_val.c_uchar;
		break;
	}
	case(C_DATATYPE_SHORT):
	{
		__u_val.c_short=__val.__u_val.c_short;
		break;
	}
	case(C_DATATYPE_INT):
	{
		__u_val.c_int=__val.__u_val.c_int;
		break;
	}
	case(C_DATATYPE_DATETIME):
	{
		__u_val.c_time=__val.__u_val.c_time;
		break;
	}
	case(C_DATATYPE_FLOAT):
	{
		__u_val.c_float=__val.__u_val.c_float;
		break;
	}
	case(C_DATATYPE_DOUBLE):
	{
		__u_val.c_double=__val.__u_val.c_double;
		break;
	}
	case(C_DATATYPE_KEYID):
	{
		__u_val.c_keyid=__val.__u_val.c_keyid;
		break;
	}
	case(C_DATATYPE_BINARY):
	{
		__u_val.c_binary= new CharSeq(*__val.__u_val.c_binary);
		break;
	}
	case(C_DATATYPE_TEXT):
	{
		__u_val.c_text= new CharSeq(*__val.__u_val.c_text);
		break;
	}
	case(C_DATATYPE_IMAGE):
	{
		__u_val.c_image= new CharSeq(*__val.__u_val.c_image);
		break;
	}
	case(C_DATATYPE_APPKEYID):
	{
		__u_val.c_appkeyid=__val.__u_val.c_appkeyid;
		break;
	}
	case(C_DATATYPE_APPID):
	{
		__u_val.c_appid=__val.__u_val.c_appid;
		break;
	}
	case(C_DATATYPE_DEFAULT):
	{
		__u_val.c_default=__val.__u_val.c_default;
		break;
	}
	case(C_DATATYPE_UINT):
	{
		__u_val.c_uint=__val.__u_val.c_uint;
		break;
	}
	case(C_DATATYPE_LONG):
	{
		__u_val.c_long=__val.__u_val.c_long;
		break;
	}
	default:
	{
		assert(0);
		break;
	}
	}//end switch
	return *this;
}
void
UDataValue::__write(MLang::OutputStream&__os)const
{
	__os.write_ushort(__u_index);
	switch(__u_index)
	{
	case(C_DATATYPE_STRING):
	{
		__os.write_string(__u_val.c_string);
		break;
	}
	case(C_DATATYPE_UCHAR):
	{
		__os.write_uchar(__u_val.c_uchar);
		break;
	}
	case(C_DATATYPE_SHORT):
	{
		__os.write_short(__u_val.c_short);
		break;
	}
	case(C_DATATYPE_INT):
	{
		__os.write_int(__u_val.c_int);
		break;
	}
	case(C_DATATYPE_DATETIME):
	{
		__os.write_long(__u_val.c_time);
		break;
	}
	case(C_DATATYPE_FLOAT):
	{
		__os.write_float(__u_val.c_float);
		break;
	}
	case(C_DATATYPE_DOUBLE):
	{
		__os.write_double(__u_val.c_double);
		break;
	}
	case(C_DATATYPE_KEYID):
	{
		__os.write_long(__u_val.c_keyid);
		break;
	}
	case(C_DATATYPE_BINARY):
	{
		MLang::VECTOR<char>&buf_0=*__u_val.c_binary;
		size_t len_0=buf_0.size();
		__os.write_uint(len_0);
		for(size_t i_0=0;i_0<len_0;i_0++)
		{
			__os.write_char_array(&buf_0[0],len_0);
			break;
		}
		break;
	}
	case(C_DATATYPE_TEXT):
	{
		MLang::VECTOR<char>&buf_1=*__u_val.c_text;
		size_t len_1=buf_1.size();
		__os.write_uint(len_1);
		for(size_t i_1=0;i_1<len_1;i_1++)
		{
			__os.write_char_array(&buf_1[0],len_1);
			break;
		}
		break;
	}
	case(C_DATATYPE_IMAGE):
	{
		MLang::VECTOR<char>&buf_2=*__u_val.c_image;
		size_t len_2=buf_2.size();
		__os.write_uint(len_2);
		for(size_t i_2=0;i_2<len_2;i_2++)
		{
			__os.write_char_array(&buf_2[0],len_2);
			break;
		}
		break;
	}
	case(C_DATATYPE_APPKEYID):
	{
		__u_val.c_appkeyid.__write(__os);
		break;
	}
	case(C_DATATYPE_APPID):
	{
		__u_val.c_appid.__write(__os);
		break;
	}
	case(C_DATATYPE_DEFAULT):
	{
		__os.write_char(__u_val.c_default);
		break;
	}
	case(C_DATATYPE_UINT):
	{
		__os.write_uint(__u_val.c_uint);
		break;
	}
	case(C_DATATYPE_LONG):
	{
		__os.write_long(__u_val.c_long);
		break;
	}
	default:
	{
		assert(0);
		break;
	}
	}
}
void
UDataValue::__read(MLang::InputStream&__is)
{
	__clear();
	__u_init=true;
	__u_index=__is.read_ushort();
	switch(__u_index)
	{
	case(C_DATATYPE_STRING):
	{
		const char*p_0=__is.read_string();
		__u_val.c_string=new char[strlen(p_0)+1];
		strcpy(__u_val.c_string,p_0);
		break;
	}
	case(C_DATATYPE_UCHAR):
	{
		__u_val.c_uchar = __is.read_uchar();
		break;
	}
	case(C_DATATYPE_SHORT):
	{
		__u_val.c_short = __is.read_short();
		break;
	}
	case(C_DATATYPE_INT):
	{
		__u_val.c_int = __is.read_int();
		break;
	}
	case(C_DATATYPE_DATETIME):
	{
		__u_val.c_time = __is.read_long();
		break;
	}
	case(C_DATATYPE_FLOAT):
	{
		__u_val.c_float = __is.read_float();
		break;
	}
	case(C_DATATYPE_DOUBLE):
	{
		__u_val.c_double = __is.read_double();
		break;
	}
	case(C_DATATYPE_KEYID):
	{
		__u_val.c_keyid = __is.read_long();
		break;
	}
	case(C_DATATYPE_BINARY):
	{
		__u_val.c_binary=new CharSeq();
		MLang::VECTOR<char>&buf_0=*__u_val.c_binary;
		size_t len_0=__is.read_uint();
		buf_0.resize(len_0);
		for(size_t i_0=0;i_0<len_0;i_0++)
		{
			__is.read_char_array(&buf_0[0],len_0);
			break;
		}
		break;
	}
	case(C_DATATYPE_TEXT):
	{
		__u_val.c_text=new CharSeq();
		MLang::VECTOR<char>&buf_1=*__u_val.c_text;
		size_t len_1=__is.read_uint();
		buf_1.resize(len_1);
		for(size_t i_1=0;i_1<len_1;i_1++)
		{
			__is.read_char_array(&buf_1[0],len_1);
			break;
		}
		break;
	}
	case(C_DATATYPE_IMAGE):
	{
		__u_val.c_image=new CharSeq();
		MLang::VECTOR<char>&buf_2=*__u_val.c_image;
		size_t len_2=__is.read_uint();
		buf_2.resize(len_2);
		for(size_t i_2=0;i_2<len_2;i_2++)
		{
			__is.read_char_array(&buf_2[0],len_2);
			break;
		}
		break;
	}
	case(C_DATATYPE_APPKEYID):
	{
		__u_val.c_appkeyid.__read(__is);
		break;
	}
	case(C_DATATYPE_APPID):
	{
		__u_val.c_appid.__read(__is);
		break;
	}
	case(C_DATATYPE_DEFAULT):
	{
		__u_val.c_default = __is.read_char();
		break;
	}
	case(C_DATATYPE_UINT):
	{
		__u_val.c_uint = __is.read_uint();
		break;
	}
	case(C_DATATYPE_LONG):
	{
		__u_val.c_long = __is.read_long();
		break;
	}
	default:
	{
		assert(0);
		break;
	}
	}
}
void
UDataValue::__clear()
{
	if(!__u_init)
		return;
	switch(__u_index)
	{
	case(C_DATATYPE_STRING):
	{
		if(__u_val.c_string!=NULL)
		{
			delete []__u_val.c_string;
			__u_val.c_string=NULL;
		}
		break;
	}
	case(C_DATATYPE_UCHAR):
	{
		break;
	}
	case(C_DATATYPE_SHORT):
	{
		break;
	}
	case(C_DATATYPE_INT):
	{
		break;
	}
	case(C_DATATYPE_DATETIME):
	{
		break;
	}
	case(C_DATATYPE_FLOAT):
	{
		break;
	}
	case(C_DATATYPE_DOUBLE):
	{
		break;
	}
	case(C_DATATYPE_KEYID):
	{
		break;
	}
	case(C_DATATYPE_BINARY):
	{
		if(__u_val.c_binary)
		{
			delete __u_val.c_binary;
			__u_val.c_binary=NULL;
		}
		break;
	}
	case(C_DATATYPE_TEXT):
	{
		if(__u_val.c_text)
		{
			delete __u_val.c_text;
			__u_val.c_text=NULL;
		}
		break;
	}
	case(C_DATATYPE_IMAGE):
	{
		if(__u_val.c_image)
		{
			delete __u_val.c_image;
			__u_val.c_image=NULL;
		}
		break;
	}
	case(C_DATATYPE_APPKEYID):
	{
		break;
	}
	case(C_DATATYPE_APPID):
	{
		break;
	}
	case(C_DATATYPE_DEFAULT):
	{
		break;
	}
	case(C_DATATYPE_UINT):
	{
		break;
	}
	case(C_DATATYPE_LONG):
	{
		break;
	}
	default:
	{
		assert(0);
		break;
	}
	}
}
void
UDataValue::c_string(const char*__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_STRING;
	__u_val.c_string= new char[strlen(__v)+1];
	strcpy(__u_val.c_string,__v);
}
void 
UDataValue::c_string(const MLang::STRING&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_STRING;
	__u_val.c_string= new char[__v.size()+1];
	strcpy(__u_val.c_string,__v.c_str());
}
void
UDataValue::c_uchar(const unsigned char __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_UCHAR;
	__u_val.c_uchar=__v;
}
void
UDataValue::c_short(const short __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_SHORT;
	__u_val.c_short=__v;
}
void
UDataValue::c_int(const int __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_INT;
	__u_val.c_int=__v;
}
void
UDataValue::c_time(const MLang::Long __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_DATETIME;
	__u_val.c_time=__v;
}
void
UDataValue::c_float(const float __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_FLOAT;
	__u_val.c_float=__v;
}
void
UDataValue::c_double(const double __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_DOUBLE;
	__u_val.c_double=__v;
}
void
UDataValue::c_keyid(const TKeyID __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_KEYID;
	__u_val.c_keyid=__v;
}
void
UDataValue::c_binary(const CharSeq&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_BINARY;
	__u_val.c_binary=new CharSeq(__v);
}
void
UDataValue::c_text(const CharSeq&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_TEXT;
	__u_val.c_text=new CharSeq(__v);
}
void
UDataValue::c_image(const CharSeq&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_IMAGE;
	__u_val.c_image=new CharSeq(__v);
}
void
UDataValue::c_appkeyid(const TAppKeyID&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_APPKEYID;
	__u_val.c_appkeyid=__v;
}
void
UDataValue::c_appid(const TAppID&__v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_APPID;
	__u_val.c_appid=__v;
}
void
UDataValue::c_default(const char __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_DEFAULT;
	__u_val.c_default=__v;
}
void
UDataValue::c_uint(const unsigned int __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_UINT;
	__u_val.c_uint=__v;
}
void
UDataValue::c_long(const MLang::Long __v)
{
	__clear();
	__u_init=true;
	__u_index=C_DATATYPE_LONG;
	__u_val.c_long=__v;
}
const char*
UDataValue::c_string()const
{
	assert(__u_init && __u_index==C_DATATYPE_STRING);
	return __u_val.c_string;
}
const unsigned char
UDataValue::c_uchar()const
{
	assert(__u_init && __u_index==C_DATATYPE_UCHAR);
	return __u_val.c_uchar;
}
const short
UDataValue::c_short()const
{
	assert(__u_init && __u_index==C_DATATYPE_SHORT);
	return __u_val.c_short;
}
const int
UDataValue::c_int()const
{
	assert(__u_init && __u_index==C_DATATYPE_INT);
	return __u_val.c_int;
}
const MLang::Long
UDataValue::c_time()const
{
	assert(__u_init && __u_index==C_DATATYPE_DATETIME);
	return __u_val.c_time;
}
const float
UDataValue::c_float()const
{
	assert(__u_init && __u_index==C_DATATYPE_FLOAT);
	return __u_val.c_float;
}
const double
UDataValue::c_double()const
{
	assert(__u_init && __u_index==C_DATATYPE_DOUBLE);
	return __u_val.c_double;
}
const TKeyID
UDataValue::c_keyid()const
{
	assert(__u_init && __u_index==C_DATATYPE_KEYID);
	return __u_val.c_keyid;
}
const CharSeq&
UDataValue::c_binary()const
{
	assert(__u_init && __u_index==C_DATATYPE_BINARY);
	return *__u_val.c_binary;
}
const CharSeq&
UDataValue::c_text()const
{
	assert(__u_init && __u_index==C_DATATYPE_TEXT);
	return *__u_val.c_text;
}
const CharSeq&
UDataValue::c_image()const
{
	assert(__u_init && __u_index==C_DATATYPE_IMAGE);
	return *__u_val.c_image;
}
const TAppKeyID&
UDataValue::c_appkeyid()const{
	assert(__u_init && __u_index==C_DATATYPE_APPKEYID);
	return __u_val.c_appkeyid;
}
const TAppID&
UDataValue::c_appid()const{
	assert(__u_init && __u_index==C_DATATYPE_APPID);
	return __u_val.c_appid;
}
const char
UDataValue::c_default()const
{
	assert(__u_init && __u_index==C_DATATYPE_DEFAULT);
	return __u_val.c_default;
}
const unsigned int
UDataValue::c_uint()const
{
	assert(__u_init && __u_index==C_DATATYPE_UINT);
	return __u_val.c_uint;
}
const MLang::Long
UDataValue::c_long()const
{
	assert(__u_init && __u_index==C_DATATYPE_LONG);
	return __u_val.c_long;
}
CharSeq&
UDataValue::c_binary()
{
	assert(__u_init && __u_index==C_DATATYPE_BINARY);
	return *__u_val.c_binary;
}
CharSeq&
UDataValue::c_text()
{
	assert(__u_init && __u_index==C_DATATYPE_TEXT);
	return *__u_val.c_text;
}
CharSeq&
UDataValue::c_image()
{
	assert(__u_init && __u_index==C_DATATYPE_IMAGE);
	return *__u_val.c_image;
}
TAppKeyID&
UDataValue::c_appkeyid(){
	assert(__u_init && __u_index==C_DATATYPE_APPKEYID);
	return __u_val.c_appkeyid;
}
TAppID&
UDataValue::c_appid(){
	assert(__u_init && __u_index==C_DATATYPE_APPID);
	return __u_val.c_appid;
}

void
TDBErrorStru::__write(MLang::OutputStream&__os)const
{
	__os.write_uint(error_no);
	__os.write_string(error_msg.c_str());
}
void
TDBErrorStru::__read(MLang::InputStream&__is)
{
	error_no=__is.read_uint();
	error_msg=__is.read_string();
}
TDBErrorStru::TDBErrorStru()
{
}
TDBErrorStru::TDBErrorStru(const TDBErrorStru&__val)
:error_no(__val.error_no),error_msg(__val.error_msg)
{

}
TDBErrorStru&
TDBErrorStru::operator=(const TDBErrorStru&__val)
{
	if(this == &__val)
		return *this;
	error_no=__val.error_no;
	error_msg=__val.error_msg;

	return *this;
}
